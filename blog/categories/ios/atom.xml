<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Code in Technicolor]]></title>
  <link href="http://Veracruz.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://Veracruz.github.io/"/>
  <updated>2014-09-24T10:24:03+08:00</updated>
  <id>http://Veracruz.github.io/</id>
  <author>
    <name><![CDATA[Veracruz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Facebook 的 Pop 开源动画库做顺畅的2D动画]]></title>
    <link href="http://Veracruz.github.io/blog/2014/07/18/use-facebookpop/"/>
    <updated>2014-07-18T15:15:58+08:00</updated>
    <id>http://Veracruz.github.io/blog/2014/07/18/use-facebookpop</id>
    <content type="html"><![CDATA[<p><em>pop</em> 是 <em>Facebook</em> 的在 <em>Paper</em> 中使用的动画库，开源之后非常受欢迎，它是一个成熟且经过良好测试的框架，使用它可以做出顺畅的2D动画。</p>

<!-- more -->


<p><em>pop</em> 的理念是一切即可动画，你不仅仅可以在一个view或者layer上做动画，它是直接在 <code>NSObject</code> 做了扩展，任意一个继承于 <code>NSObject</code> 的对象都可以添加一个动画。</p>

<p>在 <a href="https://github.com/maxmyers/FacebookPop">5 Steps For Using Facebook Pop</a> 上有一个很好的使用方法说明，官方 Repo 在这里 <a href="https://github.com/facebook/pop">facebook/pop</a>。</p>

<p>在 <em>pop</em> 中有三种是直接应用于view和layer,分别是 <code>POPBasicAnimation</code> <code>POPSpringAnimation</code> <code>POPDecayAnimation</code>，分别对应，基本动画、弹性动画、衰减动画。有一个非常好的示例程序，github上的 <a href="https://github.com/schneiderandre/popping">poping</a> 库。
在CocoaChina上有一篇好的文章 <a href="http://www.cocoachina.com/applenews/devnews/2014/0527/8565.html">Facebook Pop 使用指南</a>。</p>

<p>关于在导入库的时候，使用cocoapods是很方便的，但是如果使用复制的方式导入的话，则会遇到找不到头文件的问题，这里使用正则表达式把所有的头文件引用都替换。</p>

<p><code>Find -&gt; Find and Replace in Project</code></p>

<p>然后左边就会出现替换的对话，然后在左边栏上部选择 <code>Regular Expression</code>，接下来查找框中输入 <code>&lt;POP/([a-zA-Z.]+)&gt;</code>，替换框中输入 <code>"$1"</code>，然后preview，确定替换替换正确，然后确定即可编译成功。</p>

<p>这里说一点需要注意的地方，根据动画的类型不同，这三个属性 <code>velocity</code> <code>fromValue</code> <code>toValue</code> 必须是同一类型，例如</p>

<p><code>objectivec
POPDecayAnimation *animation = [POPDecayAnimation animationWithPropertyNamed:kPOPViewCenter];
animation.velocity = [NSValue valueWithCGPoint:CGPointMake(100, 100)];
animation.name = @"spring to center";
UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
view.center = self.view.center;
view.backgroundColor = [UIColor blueColor];
[self.view addSubview:view];
[view pop_addAnimation:animation forKey:@"decay"];
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation 中的3D变换以及简单应用]]></title>
    <link href="http://Veracruz.github.io/blog/2014/07/17/core-animation/"/>
    <updated>2014-07-17T22:36:21+08:00</updated>
    <id>http://Veracruz.github.io/blog/2014/07/17/core-animation</id>
    <content type="html"><![CDATA[<p>本篇介绍iOS中的 <em>Core Animation</em> 的3D变换，<em>CATransform3D</em> 矩阵变换。</p>

<!-- more -->


<p><em>Core Animation</em> 是iOS中自带的动画框架，它包含了一些常用的变换和动画，旋转、缩放、平移、透视等。平面的动画有 <em>facebook</em> 的 <em>pop</em> 开源框架，下一篇讲介绍。三维的框架有 <em>Unity3D</em>，通常用CA做一个3D的动画还是很繁琐的，iOS上的 <em>OpenGL ES</em> 可能更科学。</p>

<p>这个层面已经涉及到一些计算机图形学的知识，这里只说明基本的意义。</p>

<p>首先，通过查看 <em>CATransform3D</em> 的定义可以知道，这是一个三维齐次变换矩阵。</p>

<p>左上到右下的对角线是1，而其他的都为0的时候，就是 <code>CATransform3DIdentity</code> 变换，即恒等变换。一般的常用变换，CA都给出了一些C函数，例如 <code>CATransform3DRotate()</code>。</p>

<p>这些操作都是在一个layer上，<code>layer.anchorPoint</code> 这个属性会影响到一些变换，比如旋转的轴。</p>

<p>这里提一下iOS中坐标系的问题，CA中用的是左手坐标系，x轴正方向向右，y轴正方向向下，z轴正方向垂直于屏幕向上，也就是朝着用户的方向。所以这里，旋转的正方向就是顺时针，而旋转的角度的范围事实上为-180到180，所以如果使用变换来做动画，则使用 <code>CAKeyFrameAnimation</code> 来实现超过180度的旋转动画，而使用keypath的方式就不需要。</p>

<p>在做animation的时候，使用 <code>CABasicAnimation</code> 用 <em>keypath</em> 来添加动画，这里有一个非官方的不完整列表，官方似乎并未提供完整列表。转载自<a href="http://www.cnblogs.com/pengyingh/articles/2379631.html">CABasicAnimation animationWithKeyPath 一些规定的值</a></p>

<ul>
<li>sublayerTransform</li>
<li>transform</li>
<li>rotation</li>
<li>scale</li>
<li>translation</li>
<li>opacity</li>
<li>margin</li>
<li>zPosition</li>
<li>backgroundColor</li>
<li>cornerRadius</li>
<li>borderWidth</li>
<li>bounds</li>
<li>contents</li>
<li>contentsRect</li>
<li>cornerRadius</li>
<li>frame</li>
<li>hidden</li>
<li>mask</li>
<li>masksToBounds</li>
<li>opacity</li>
<li>position</li>
<li>shadowColor</li>
<li>shadowOffset</li>
<li>shadowOpacity</li>
<li>shadowRadius</li>
</ul>


<p>其中有一些是可以用 <code>.</code> 来连接子属性的，例如 <code>rotation.x</code>。</p>

<p>有一个简单明了的示例是Mgen的一个旋转立方体，我这里给出 <code>ViewController.m</code> 的完整代码和我增加的几条注释，转载自<a href="http://www.mgenware.com/blog/?p=498">iOS CALayer和3D (1): 定义一个简单的旋转3D立方体</a>。</p>

<p>```objc
//
//  ViewController.m
//  CALayer_3DCube_from_Mgen_Blog
//
//  Created by Veracruz on 14-7-17.
//  Copyright &copy; 2014年 Veracruz. All rights reserved.
//</p>

<h1>import &ldquo;ViewController.h&rdquo;</h1>

<p>@interface ViewController ()</p>

<p>@property (strong, nonatomic) CALayer *rootLayer; //主layer，这里应理解为一个放置layer的舞台</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];
  // Do any additional setup after loading the view, typically from a nib.</p>

<p>  <em>rootLayer = [CALayer layer];
  </em>rootLayer.contentsScale = [UIScreen mainScreen].scale;
  _rootLayer.frame =self.view.bounds;</p>

<p>  //前
  [self addLayer:@[@0, @0, @50, @0, @0, @0, @0]];
  //后
  [self addLayer:@[@0, @0, @(-50), @(M_PI), @0, @0, @0]];
  //左
  [self addLayer:@[@(-50), @0, @0, @(-M_PI_2), @0, @1, @0]];
  //右
  [self addLayer:@[@50, @0, @0, @(M_PI_2), @0, @1, @0]];
  //上
  [self addLayer:@[@0, @(-50), @0, @(-M_PI_2), @1, @0, @0]];
  //下
  [self addLayer:@[@0, @50, @0, @(M_PI_2), @1, @0, @0]];</p>

<p>  //主Layer的3D变换
  CATransform3D transform = CATransform3DIdentity;
  //这是做了一个透视
  transform.m34 = -1.0 / 700;
  //在X轴上做一个20度的小旋转
  transform = CATransform3DRotate(transform, M_PI / 9, 1, 0, 0);
  //设置CALayer的sublayerTransform
  <em>rootLayer.sublayerTransform = transform;
  //添加Layer
  [self.view.layer addSublayer:</em>rootLayer];</p>

<p>  //动画
  CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&ldquo;sublayerTransform.rotation.y&rdquo;];
  //从0到360度
  animation.toValue = [NSNumber numberWithFloat:2 * M_PI];
  //间隔3秒
  animation.duration = 3.0;
  //无限循环
  animation.repeatCount = HUGE_VALF;
  //开始动画
  [_rootLayer addAnimation:animation forKey:@&ldquo;rotation&rdquo;];
}</p></li>
<li><p>(void)addLayer:(NSArray <em>)params
{
  //可以渐变颜色的layer
  CAGradientLayer </em>gradientLayer = [CAGradientLayer layer];</p>

<p>  //这句似乎在有内容的时候才是必须的
  gradientLayer.contentsScale = [UIScreen mainScreen].scale;</p>

<p>  gradientLayer.bounds = CGRectMake(0, 0, 100, 100);
  gradientLayer.position = self.view.center;</p>

<p>  //设置渐变的颜色序列
  gradientLayer.colors = @[(id)[UIColor grayColor].CGColor,
                           (id)[UIColor blackColor].CGColor];
  //设置每个颜色起始的比例位置
  gradientLayer.locations = @[@0, @1];</p>

<p>  //两个点的连线就是渐变的方向
  gradientLayer.startPoint = CGPointMake(0, 0);
  gradientLayer.startPoint = CGPointMake(0, 1);</p>

<p>  CATransform3D transform =
      CATransform3DMakeTranslation([[params objectAtIndex:0] floatValue],
                                   [[params objectAtIndex:1] floatValue],
                                   [[params objectAtIndex:2] floatValue]);
  transform =
      CATransform3DRotate(transform,
                          [[params objectAtIndex:3] floatValue],
                          [[params objectAtIndex:4] floatValue],
                          [[params objectAtIndex:5] floatValue],
                          [[params objectAtIndex:6] floatValue]);</p>

<p>  gradientLayer.transform = transform;</p>

<p>  [_rootLayer addSublayer:gradientLayer];
}</p></li>
<li><p>(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
</ul>


<p>@end
```</p>

<p>上面代码实现了一个立方体的旋转动画，通过这段代码即可了解CA中的变换和动画的一些用法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking & ASIHTTPRequest 的初步使用方法]]></title>
    <link href="http://Veracruz.github.io/blog/2014/07/16/afnetworking-and-asihttprequest/"/>
    <updated>2014-07-16T13:54:07+08:00</updated>
    <id>http://Veracruz.github.io/blog/2014/07/16/afnetworking-and-asihttprequest</id>
    <content type="html"><![CDATA[<p>总结一下 <em>AFNetworking</em> 和 <em>ASIHTTPRequest</em> 两个网络库的基本使用以及一些问题</p>

<!-- more -->


<p>首先到 <em>github</em> 下载这两个库，<em>ASIHTTPRequest</em> 从2011年就停止更新了，写这篇文章的时候 <em>AFNetworking</em> 的版本是 <code>2.3.1</code>。</p>

<p>当前使用的环境是</p>

<p><code>
Mac OS X 10.9.4
Xcode 5.1.1
iOS 7.1
</code></p>

<p>下面是两个库的地址</p>

<p><code>https://github.com/pokeb/asi-http-request</code></p>

<p><code>https://github.com/AFNetworking/AFNetworking</code></p>

<p>这两个库都封装了网络的一些操作，可以方便的进行各种Request，包含一些高级的功能，另外还有一个库MKNetworking可以选择，下面有一个对比的表格，转载自 <a href="http://www.cnblogs.com/snake-hand/p/3177938.html">AFNetworking、MKNetworkKit和ASIHTTPRequest对比</a></p>

<table class="ynote_table" style="border-width: 1px; border-style: solid; border-color: #999999; border-collapse: collapse; margin: 6px auto; width: 100%;" border="1" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>&nbsp;</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>AFNetworking</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>MKNetworkKit</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">ASIHTTPRequest</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">更新情况</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">维护和使用者相对多</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">维护和使用者相对少</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">停止更新</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>支持iOS和OSX</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>ARC</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>断点续传</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top"><span style="font-size: 12px; line-height: 18px;">否，可通过</span><span style="font-size: 12px; line-height: 18px;">AFDownloadRequestOperation</span></td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">同步异步请求</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">只支持异步</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>图片缓存到本地</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>否，通过SDURLCache或AFCache</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>否</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>图片缓存到内存</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">后台下载</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">下载进度</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否，可通过AFDownloadRequestOperation</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">缓存离线请求</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否，<span style="font-size: 12px; line-height: 18px;">通过SDURLCache或AFCache</span></td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">JSON、XML</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
</tbody>
</table>




<br /><br /><br />


<h2>AFNetworking</h2>

<p>这个框架现在的版本和以前的用法有一些区别，而且有一些设置比较隐蔽。其中扩展了一些系统的UI类，可以非常方便的使用UIProgressView、UIImageView等实现进度条，图片加载等功能。</p>

<br /><br />


<h3>导入库</h3>

<hr />

<p>只要将下载之后的目录下的 <code>AFNetworking</code> 和 <code>UIKit+AFNetworking</code> 两个文件夹导入到工程即可，并且不需要添加其他框架。</p>

<br /><br />


<h3>GET请求并解析JSON</h3>

<hr />

<p>它有自己的管理类，这种请求非常简单明了，会直接解析JSON到一个 <code>NSDictionary</code>，当然前提是返回的响应是很规范的，可是很多时候并不是这样。这种请求方式要求响应头中的 <code>Content-type</code> 字段的值必须是 <code>text/json</code>，也就是<code>Content-type: text/json</code>。很多时候返回的响应头这个字段的值是 <code>text/html</code>, 这个时候这个库就会返回一个错误。当然错误格式的JSON数据也会返回错误。下面是调用的代码段.</p>

<p>``` objectivec
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</p>

<p>//设置支持所有的MIME格式，略隐蔽的设置选项
manager.responseSerializer.acceptableContentTypes = nil;</p>

<p>[manager GET:JSON_URL parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {</p>

<pre><code>NSLog(@"%@ : ", [responseObject class], responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
NSLog(@"error : %@", error);
}];
</code></pre>

<p>```</p>

<br /><br />


<h3>通用请求</h3>

<hr />

<p>这个库提供了响应的序列化器(serializer)，就是解析器，这个可以自己定制，如果不指定则不会解析，仅接收原始数据在block的参数 <code>responseObject</code> 中。<code>operation</code>有很多有用的属性，例如<code>operation.response.allHeaderFields</code> 可以查看完整的响应头。下面这段代码指定了XML的序列化器。</p>

<p>``` objectivec
NSURLRequest <em>request = [NSURLRequest requestWithURL:[NSURL URLWithString:SOME_URL]];
AFHTTPRequestOperation </em>operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];</p>

<p>//指定序列化器
operation.responseSerializer = [AFXMLParserResponseSerializer serializer];</p>

<p>[operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {</p>

<pre><code>NSLog(@"%@ : ", [responseObject class], responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
NSLog(@"error : %@", error);
}];
</code></pre>

<p>[[NSOperationQueue mainQueue] addOperation:operation];
```从上面的代码的输出可以看到，它使用了iOS自带的XML解析器。</p>

<h3>文件下载保存</h3>

<hr />

<p>下面的代码很方便的实现了一个文件的下载。
```objectivec
AFURLSessionManager <em>manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSURLRequest </em>request = [NSURLRequest requestWithURL:[NSURL URLWithString:FILE_URL]];</p>

<p>NSURLSessionDownloadTask <em>task = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL </em>(NSURL <em>targetPath, NSURLResponse </em>response)</p>

<pre><code>{
NSURL *documentURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
return [documentURL URLByAppendingPathComponent:FILE_NAME];
} completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error)
{
NSLog(@"error : %@", error);
}];
</code></pre>

<p>//不要忘记开始任务
[task resume];
```</p>

<br /><br /><br />


<h2>ASIHTTPRequest</h2>

<p>这个停止更新很久的库使用的是MRC，并且在新的系统中使用可能会遇到一些问题，但确实一个很好地库，支持断点续传、缓存、身份验证等等。</p>

<br /><br />


<h3>导入库</h3>

<hr />

<p>下载库之后，将目录下的 <code>Classes</code> 和 <code>External</code> 文件夹导入到项目中，这并不是完整的导入，它的单元测试模块的一些文件并不包含在这个目录中，需要用 <em>ruby</em> 相关的命令来导入。这里只需要删除 <code>Classes</code> 目录下的 <code>Test</code> 删除即可。</p>

<br /><br />


<h3>项目设置</h3>

<hr />

<p>需要添加以下框架和库</p>

<p><code>CFNetworking.framework</code>
<code>SystemConfiguration.framework</code>
<code>MobileCoreServices.framework</code>
<code>libz.dylib</code>
<code>libxml2.dylib</code></p>

<p>还要在项目的 <code>Build Settings</code> 中的 <code>Header Search Paths</code> 字段中添加 <code>/usr/include/libxml2/</code>。</p>

<p>如果项目是ARC，请在这个库的所有文件添加标签 <code>-fnobjectivec-arc</code>，在 <code>Build Phases</code> 中的 <code>Compile Sources</code>。或者也可以把项目改成mrc而你自己创建的文件添加标签 <code>-fobjectivec-arc</code>。</p>

<p>另外在64位的iOS系统下会有很多类型警告，按照推荐的修改即可。</p>

<br /><br />


<h3>数据请求</h3>

<hr />

<p>有同步和异步请求，同步的意义不大，这里给出异步请求。请求的处理有两种方式，一种是代理，一种是 <code>block</code>。下面给出 <code>block</code> 方式的，代理方式在 <code>ASIHTTPRequestDelegate</code> 的文件中的定义很容易理解。</p>

<p>``` objectivec
NSURL *url = [NSURL URLWithString:SOME_URL];</p>

<p>//使用<strong>weak来防止使用block出现的retain循环
</strong>weak ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];</p>

<p>//使用代理方式则添加下面这句
//request.delegate = self;</p>

<p>[request setCompletionBlock:^{</p>

<pre><code>NSLog(@"%@", request.responseString);
}];
</code></pre>

<p>[request setFailedBlock:^{</p>

<pre><code>NSLog(@"%@", request.error);
}];
</code></pre>

<p>[request startAsynchronous];
```</p>

<br /><br />


<h3>文件下载缓存</h3>

<hr />

<p>支持多种缓存策略，这里使用永久缓存的策略。</p>

<p>``` objectivec
NSURL <em>url = [NSURL URLWithString:FILE_URL];
__weak ASIHTTPRequest </em>request = [ASIHTTPRequest requestWithURL:url];</p>

<p>request.downloadCache = [ASIDownloadCache sharedCache];</p>

<p>//指定缓存策略
request.cachePolicy = ASIOnlyLoadIfNotCachedCachePolicy;</p>

<p>[request setCompletionBlock:^{</p>

<pre><code>[request.responseData writeToFile:LOCAL_FILE_URL atomically:YES];
}];
</code></pre>

<p>[request setFailedBlock:^{</p>

<pre><code>NSLog(@"%@", request.error);
}];
</code></pre>

<p>[request startAsynchronous];
```</p>

<p>下载任务是支持进度显示的，需要用一个UIProgressView代理，和设置显示精确进度，下面两句</p>

<p><code>objectivec
request.showAccurateProgress = YES;
request.downloadProgressDelegate = progressView;
</code></p>

<hr />

<hr />

<br /><br />


<p>以上就是两个库的基本用法，还有一些上传数据，身份验证等等点击下面的参考资料中的链接查看。</p>

<br /><br /><br /><br />


<h4>参考资料</h4>

<hr />

<ol>
<li><a href="http://mobile.51cto.com/iphone-405168.htm">专题：iOS教程之ASIHttpRequest完全攻略</a></li>
<li><a href="http://allseeing-i.com/ASIHTTPRequest/How-to-use">ASIHTTPRequest 官方文档</a></li>
<li><a href="http://cocoadocs.org/docsets/AFNetworking/2.3.1/index.html">AFNetworking 官方文档</a></li>
</ol>

]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Code in Technicolor]]></title>
  <link href="http://Veracruz.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://Veracruz.github.io/"/>
  <updated>2014-07-16T17:57:16+08:00</updated>
  <id>http://Veracruz.github.io/</id>
  <author>
    <name><![CDATA[Veracruz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AFNetworking & ASIHTTPRequest 的初步使用方法]]></title>
    <link href="http://Veracruz.github.io/blog/2014/07/16/afnetworking-and-asihttprequest/"/>
    <updated>2014-07-16T13:54:07+08:00</updated>
    <id>http://Veracruz.github.io/blog/2014/07/16/afnetworking-and-asihttprequest</id>
    <content type="html"><![CDATA[<p>总结一下 <em>AFNetworking</em> 和 <em>ASIHTTPRequest</em> 两个网络库的基本使用以及一些问题</p>

<!-- more -->


<p>首先到 <em>github</em> 下载这两个库，<em>ASIHTTPRequest</em> 从2011年就停止更新了，写这篇文章的时候 <em>AFNetworking</em> 的版本是 <code>2.3.1</code>。</p>

<p>当前使用的环境是</p>

<pre><code>Mac OS X 10.9.4
Xcode 5.1.1
iOS 7.1
</code></pre>

<p>下面是两个库的地址</p>

<p><code>https://github.com/pokeb/asi-http-request</code></p>

<p><code>https://github.com/AFNetworking/AFNetworking</code></p>

<p>这两个库都封装了网络的一些操作，可以方便的进行各种Request，包含一些高级的功能，另外还有一个库MKNetworking可以选择，下面有一个对比的表格，转载自 <a href="http://www.cnblogs.com/snake-hand/p/3177938.html">AFNetworking、MKNetworkKit和ASIHTTPRequest对比</a></p>

<table class="ynote_table" style="border-width: 1px; border-style: solid; border-color: #999999; border-collapse: collapse; margin: 6px auto; width: 100%;" border="1" cellspacing="0" cellpadding="2">
<tbody>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>&nbsp;</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>AFNetworking</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>MKNetworkKit</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">ASIHTTPRequest</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">更新情况</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">维护和使用者相对多</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">维护和使用者相对少</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">停止更新</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>支持iOS和OSX</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>ARC</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>断点续传</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top"><span style="font-size: 12px; line-height: 18px;">否，可通过</span><span style="font-size: 12px; line-height: 18px;">AFDownloadRequestOperation</span></td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">同步异步请求</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">只支持异步</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>图片缓存到本地</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>否，通过SDURLCache或AFCache</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>否</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>图片缓存到内存</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">
<div>是</div>
</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">后台下载</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">下载进度</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否，可通过AFDownloadRequestOperation</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">缓存离线请求</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否，<span style="font-size: 12px; line-height: 18px;">通过SDURLCache或AFCache</span></td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
<tr>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">JSON、XML</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">是</td>
<td style="word-break: break-all; border: #999999 1px solid;" valign="top">否</td>
</tr>
</tbody>
</table>


<p><br /><br /><br /></p>

<h2>AFNetworking</h2>

<p>这个框架现在的版本和以前的用法有一些区别，而且有一些设置比较隐蔽。其中扩展了一些系统的UI类，可以非常方便的使用UIProgressView、UIImageView等实现进度条，图片加载等功能。</p>

<p><br /><br /></p>

<h3>导入库</h3>

<hr />

<p>只要将下载之后的目录下的 <code>AFNetworking</code> 和 <code>UIKit+AFNetworking</code> 两个文件夹导入到工程即可，并且不需要添加其他框架。</p>

<p><br /><br /></p>

<h3>GET请求并解析JSON</h3>

<hr />

<p>它有自己的管理类，这种请求非常简单明了，会直接解析JSON到一个 <code>NSDictionary</code>，当然前提是返回的响应是很规范的，可是很多时候并不是这样。这种请求方式要求响应头中的 <code>Content-type</code> 字段的值必须是 <code>text/json</code>，也就是<code>Content-type: text/json</code>。很多时候返回的响应头这个字段的值是 <code>text/html</code>, 这个时候这个库就会返回一个错误。当然错误格式的JSON数据也会返回错误。下面是调用的代码段.</p>

<pre><code class="objectivec ">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];

//设置支持所有的MIME格式，略隐蔽的设置选项
manager.responseSerializer.acceptableContentTypes = nil;

[manager GET:JSON_URL parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"%@ : ", [responseObject class], responseObject);
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"error : %@", error);
    }];
</code></pre>

<p><br /><br /></p>

<h3>通用请求</h3>

<hr />

<p>这个库提供了响应的序列化器(serializer)，就是解析器，这个可以自己定制，如果不指定则不会解析，仅接收原始数据在block的参数 <code>responseObject</code> 中。<code>operation</code>有很多有用的属性，例如<code>operation.response.allHeaderFields</code> 可以查看完整的响应头。下面这段代码指定了XML的序列化器。</p>

<pre><code class="objectivec ">NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:SOME_URL]];
AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];

//指定序列化器
operation.responseSerializer = [AFXMLParserResponseSerializer serializer];

[operation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"%@ : ", [responseObject class], responseObject);
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"error : %@", error);
    }];

[[NSOperationQueue mainQueue] addOperation:operation];
</code></pre>

<h3>文件下载保存</h3>

<hr />

<p>下面的代码很方便的实现了一个文件的下载。
```objectivec
AFURLSessionManager <em>manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
NSURLRequest </em>request = [NSURLRequest requestWithURL:[NSURL URLWithString:FILE_URL]];</p>

<p>NSURLSessionDownloadTask <em>task = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL </em>(NSURL <em>targetPath, NSURLResponse </em>response)
    {
    NSURL <em>documentURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
    return [documentURL URLByAppendingPathComponent:FILE_NAME];
    } completionHandler:^(NSURLResponse </em>response, NSURL <em>filePath, NSError </em>error)
    {
    NSLog(@&ldquo;error : %@&rdquo;, error);
    }];</p>

<p>//不要忘记开始任务
[task resume];
```</p>

<p><br /><br /><br /></p>

<h2>ASIHTTPRequest</h2>

<p>这个停止更新很久的库使用的是MRC，并且在新的系统中使用可能会遇到一些问题，但确实一个很好地库，支持断点续传、缓存、身份验证等等。</p>

<p><br /><br /></p>

<h3>导入库</h3>

<hr />

<p>下载库之后，将目录下的 <code>Classes</code> 和 <code>External</code> 文件夹导入到项目中，这并不是完整的导入，它的单元测试模块的一些文件并不包含在这个目录中，需要用 <em>ruby</em> 相关的命令来导入。这里只需要删除 <code>Classes</code> 目录下的 <code>Test</code> 删除即可。</p>

<p><br /><br /></p>

<h3>项目设置</h3>

<hr />

<p>需要添加以下框架和库</p>

<p><code>CFNetworking.framework</code>
<code>SystemConfiguration.framework</code>
<code>MobileCoreServices.framework</code>
<code>libz.dylib</code>
<code>libxml2.dylib</code></p>

<p>还要在项目的 <code>Build Settings</code> 中的 <code>Header Search Paths</code> 字段中添加 <code>/usr/include/libxml2/</code>。</p>

<p>如果项目是ARC，请在这个库的所有文件添加标签 <code>-fnobjectivec-arc</code>，在 <code>Build Phases</code> 中的 <code>Compile Sources</code>。或者也可以把项目改成mrc而你自己创建的文件添加标签 <code>-fobjectivec-arc</code>。</p>

<p>另外在64位的iOS系统下会有很多类型警告，按照推荐的修改即可。</p>

<p><br /><br /></p>

<h3>数据请求</h3>

<hr />

<p>有同步和异步请求，同步的意义不大，这里给出异步请求。请求的处理有两种方式，一种是代理，一种是 <code>block</code>。下面给出 <code>block</code> 方式的，代理方式在 <code>ASIHTTPRequestDelegate</code> 的文件中的定义很容易理解。</p>

<pre><code class="objectivec ">NSURL *url = [NSURL URLWithString:SOME_URL];

//使用__weak来防止使用block出现的retain循环
__weak ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];

//使用代理方式则添加下面这句
//request.delegate = self;

[request setCompletionBlock:^{
    NSLog(@"%@", request.responseString);
    }];
[request setFailedBlock:^{
    NSLog(@"%@", request.error);
    }];
[request startAsynchronous];
</code></pre>

<p><br /><br /></p>

<h3>文件下载缓存</h3>

<hr />

<p>支持多种缓存策略，这里使用永久缓存的策略。</p>

<pre><code class="objectivec ">NSURL *url = [NSURL URLWithString:FILE_URL];
__weak ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];

request.downloadCache = [ASIDownloadCache sharedCache];

//指定缓存策略
request.cachePolicy = ASIOnlyLoadIfNotCachedCachePolicy;

[request setCompletionBlock:^{
    [request.responseData writeToFile:LOCAL_FILE_URL atomically:YES];
    }];
[request setFailedBlock:^{
    NSLog(@"%@", request.error);
    }];

[request startAsynchronous];
</code></pre>

<p>下载任务是支持进度显示的，需要用一个UIProgressView代理，和设置显示精确进度，下面两句</p>

<pre><code class="objectivec">request.showAccurateProgress = YES;
request.downloadProgressDelegate = progressView;
</code></pre>

<hr />

<hr />

<p><br /><br /></p>

<p>以上就是两个库的基本用法，还有一些上传数据，身份验证等等点击下面的参考资料中的链接查看。</p>

<p><br /><br /><br /><br /></p>

<h4>参考资料</h4>

<hr />

<ol>
<li><a href="http://mobile.51cto.com/iphone-405168.htm">专题：iOS教程之ASIHttpRequest完全攻略</a></li>
<li><a href="http://allseeing-i.com/ASIHTTPRequest/How-to-use">ASIHTTPRequest 官方文档</a></li>
<li><a href="http://cocoadocs.org/docsets/AFNetworking/2.3.1/index.html">AFNetworking 官方文档</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
